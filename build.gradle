

/*
 * Copyright (c) 2014, The MITRE Corporation. All rights reserved.
 * See LICENSE for complete terms.
 *
 * Java-STIX Gradle Buildscript
 *
 * nemonik (Michael Joseph Walsh <github.com@nemonik.com>)
 *
 * Run
 *
 *	gradle
 *
 * from the commnand-line.
 *
 * Jar will be built to 
 *
 * 	build/libs/java-stix-${version}.jar
 */

import groovy.io.FileType
import groovy.text.SimpleTemplateEngine
import groovy.xml.StreamingMarkupBuilder
import groovy.xml.XmlUtil

import java.io.ByteArrayInputStream
import java.io.File
import java.nio.file.FileSystems
import java.io.InputStream
import java.text.SimpleDateFormat
import java.util.ArrayList;
import java.util.Date
import java.util.Hashtable;
import java.util.List
import java.util.Map;
import java.util.regex.Matcher
import java.util.regex.Pattern

import javax.xml.bind.JAXBContext
import javax.xml.bind.JAXBElement
import javax.xml.bind.JAXBException
import javax.xml.bind.Marshaller
import javax.xml.bind.Unmarshaller
import javax.xml.namespace.QName
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.parsers.ParserConfigurationException
import javax.xml.transform.stream.StreamSource

import org.eclipse.jdt.core.JavaCore
import org.eclipse.jdt.core.ToolFactory
import org.eclipse.jdt.core.compiler.IProblem
import org.eclipse.jdt.core.dom.AST
import org.eclipse.jdt.core.dom.ASTNode
import org.eclipse.jdt.core.dom.ASTParser
import org.eclipse.jdt.core.dom.CompilationUnit
import org.eclipse.jdt.core.dom.ImportDeclaration
import org.eclipse.jdt.core.dom.TypeDeclaration
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite
import org.eclipse.jdt.core.dom.rewrite.ListRewrite
import org.eclipse.jdt.core.formatter.CodeFormatter
import org.eclipse.jdt.core.formatter.DefaultCodeFormatterConstants
import org.eclipse.jface.text.Document
import org.eclipse.text.edits.TextEdit

import org.w3c.dom.Document
import org.apache.tools.ant.taskdefs.condition.Os


apply plugin: 'java'
apply plugin: 'eclipse'

defaultTasks 'jar'

version = 0.1

// Will attempt to automatically retrieve the schemas
class RetrieveSchemasTask extends DefaultTask {

	def isRetrievable() {
		def command = """git ls-remote --exit-code -h https://github.com/nemonik/java_stix.git"""
		def proc = command.execute()
		proc.waitFor()
		proc.exitValue() == 0
	}

	def pull() {
		def command = null

		if (Os.isFamily(Os.FAMILY_WINDOWS)) {
			//TODO: not tested
			command = """cmd /c start retrieve_schemas.bat"""
		} else {
			command = """sh ./retrieve_schemas.sh"""
		}

		def proc = command.execute()
		proc.waitFor()

		println "${proc.in.text}"
	}

	@TaskAction
	def retrieve() {

		def command = null

		if (Os.isFamily(Os.FAMILY_WINDOWS)) {
			//TODO: not tested
			command = "dir"
		} else {
			command = "ls"
		}
		
		command += " " + ["src", "main", "resources", "schemas"]
				.join(System.getProperty("file.separator"))
				
		println command
	
		def proc = command.execute()
		proc.waitFor()

		def needSchemas = true

		if (!proc.in.text.equals("")) {

			if (Os.isFamily(Os.FAMILY_WINDOWS)) {
				//TODO: not tested
				command = "dir"
			} else {
				command = "ls"
			}
			
			command += " " + ["src","main","resources","schemas","cybox"]
					.join(System.getProperty("file.separator"))
					
			println command

			proc = command.execute()
			proc.waitFor()

			if (!proc.in.text.equals("")) {
				needSchemas = false
			}
		}

		if (needSchemas) {
			if (isRetrievable()) {
				pull()
			} else {
				throw new GradleException("Build error occurred: You will need retrieve schemas by hand. See README.md file.");
			}
		} else {
			println "Schemas are present. Retrieval is not needed."
		}
	}
}

// Analyze and transform the generated document object model source. Creating
// an XJC plug would take too long and introduce the compilation of an external
// project as a dependency, and adding them via bindings file is too brittle.
// So, gradle to the rescue.
class GeneratedSourceTransformationTask extends DefaultTask {

	def lineSeperator = System.getProperty("line.separator")

	// Format src
	def format(src) {

		def options = DefaultCodeFormatterConstants.getEclipseDefaultSettings()
		options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5)
		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_5)
		options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_5)

		def codeFormatter = ToolFactory.createCodeFormatter(options)

		def edit = codeFormatter.format(
				CodeFormatter.K_COMPILATION_UNIT,
				src,
				0,
				src.length(),
				0,
				lineSeperator
				)

		def document = new org.eclipse.jface.text.Document(src)

		try {
			edit.apply(document)
		} catch (Exception e) {
			e.printStackTrace()
		}

		document.get()
	}

	// Add a imports to source and organizes them
	def addImportsToSrc(source, importsToAdd) {
		def document = new org.eclipse.jface.text.Document(source)

		def parser = ASTParser.newParser(AST.JLS8)

		def options = JavaCore.getOptions()
		options.put(JavaCore.COMPILER_COMPLIANCE, "1.5")
		options.put(JavaCore.COMPILER_SOURCE, "1.5")
		parser.setCompilerOptions(options)

		parser.setSource(document.get().toCharArray())
		parser.setKind(ASTParser.K_COMPILATION_UNIT)

		def cu = (CompilationUnit) parser.createAST(null)
		
		if (!(cu.types().get(0) instanceof org.eclipse.jdt.core.dom.EnumDeclaration)) {
			cu.recordModifications()
	
			def ast = cu.getAST();
	
			def importMembers = []
	
			cu.imports().each { importDecl ->
				importMembers << importDecl.getName().toString()
			}
	
			cu.imports().clear()
	
			importsToAdd.each { member ->
				if (!importMembers.contains(member)) {
					importMembers << member
				}
			}
	
			importMembers.sort()
	
			importMembers.each { member ->
				def importDeclaration = ast.newImportDeclaration();
				importDeclaration.setName(ast.newName(member.split("\\.")))
	
				cu.imports().add(importDeclaration)
			}
	
			TextEdit edits = cu.rewrite(document, null)
			edits.apply(document)
		}

		document.get()
	}

	// Add methods to source
	def addMethodsToSrc(source, methodTemplates, templateBindings) {

		def document = new org.eclipse.jface.text.Document(source)
		def parser = ASTParser.newParser(AST.JLS8)

		def options = JavaCore.getOptions()
		options.put(JavaCore.COMPILER_COMPLIANCE, "1.5")
		options.put(JavaCore.COMPILER_SOURCE, "1.5")

		parser.setCompilerOptions(options)

		parser.setSource(document.get().toCharArray())
		parser.setKind(ASTParser.K_COMPILATION_UNIT)

		def cu = (CompilationUnit) parser.createAST(null)
		
		if (!(cu.types().get(0) instanceof org.eclipse.jdt.core.dom.EnumDeclaration)) {
			cu.recordModifications()
	
			def rewriter = ASTRewrite.create(cu.getAST())
	
			def engine = new SimpleTemplateEngine()

			methodTemplates.each { methodTemplate ->
				def template = engine.createTemplate(methodTemplate).make(templateBindings)
				def methodSource = template.toString()

				def lrw = rewriter.getListRewrite((TypeDeclaration) cu.types().get(0),
						TypeDeclaration.BODY_DECLARATIONS_PROPERTY)

				lrw.insertLast(rewriter.createStringPlaceholder(methodSource,
						ASTNode.METHOD_DECLARATION), null)

			}

			def edits = rewriter.rewriteAST(document, null)
			edits.apply(document)
			
		}

		document.get()
	}

	@TaskAction
	def sourceTransformation() {

		def addMethods = [
			/(.*)/: [
				imports: [
					'java.io.ByteArrayInputStream',
					'java.io.IOException',
					'java.io.InputStream',
					'javax.xml.bind.JAXBContext',
					'javax.xml.bind.JAXBElement',
					'javax.xml.bind.JAXBException',
					'javax.xml.bind.Marshaller',
					'javax.xml.bind.Unmarshaller',
					'javax.xml.namespace.QName',
					'javax.xml.parsers.DocumentBuilderFactory',
					'javax.xml.parsers.ParserConfigurationException',
					'javax.xml.transform.stream.StreamSource',
					'org.mitre.stix.util.Utilities',
					'org.w3c.dom.Document'
				],
				methodTemplates: [
					"""\
    /**
     * Returns XML String for JAXB Document Object Model object.
     * 
     * @param obj
     * @return the XML String for the JAXB object
     * @throws JAXBException
     * @throws ParserConfigurationException
     */
    public String toXMLString() throws JAXBException,
            ParserConfigurationException {
        Document document = DocumentBuilderFactory
                .newInstance().newDocumentBuilder().newDocument();

        JAXBContext jaxbContext = JAXBContext
                .newInstance(this.getClass().getPackage().getName());

        Marshaller marshaller = jaxbContext.createMarshaller();

        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,
                true);

        marshaller
                .setProperty(Marshaller.JAXB_ENCODING, "UTF-8");

        try {
            marshaller.marshal(this, document);
        } catch (JAXBException e) {
            // otherwise handle non-XMLRootElements
            QName qualifiedName = new QName(
                    Utilities.getnamespaceURI(this), this
                            .getClass().getSimpleName());

            @SuppressWarnings({ "rawtypes", "unchecked" })
            JAXBElement root = new JAXBElement(
                    qualifiedName, this.getClass(), this);

            marshaller.marshal(root, document);
        }

        Utilities.removeUnusedNamespaces(document);

        document = Utilities.addSchemaLocations(document);

        return Utilities.getXMLString(document);
    }
""",
					"""\
    /**
     * Creates JAXB Document Object Model for XML text string
     * 
     * @param text
     *            XML string for the document
     * @return JAXB object
     * @throws JAXBException
     * @throws IOException
     */
    public static \${name} fromXMLString(String text)
            throws JAXBException, IOException {

        JAXBContext jaxbContext;
        InputStream inputStream = null;

        @SuppressWarnings("rawtypes")
        JAXBElement root = null;

        jaxbContext = JAXBContext.newInstance(\${name}.class
                .getPackage().getName());

        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();

        inputStream = new ByteArrayInputStream(text.getBytes());

        root = unmarshaller.unmarshal(new StreamSource(inputStream),
                \${name}.class);

        inputStream.close();

        return (\${name}) root.getValue();
    }
"""
				]]]

		//		def replaceCode = [
		//			/(org.mitre.stix.stix_1.STIXType) |
		//			(org.mitre.stix.indicator_2.IndicatorType) |
		//			(org.mitre.stix.incident_1.IncidentType) |
		//			(org.mitre.stix.ttp_1.TTPType) |
		//			(org.mitre.stix.threatactor_1.ThreatActorType) |
		//			(org.mitre.stix.campaign_1.CampaignType) |
		//			(org.mitre.stix.exploittarget_1.ExploitTargetType) |
		//			(org.mitre.stix.courseofaction_1.CourseOfActionType) |
		//			(org.mitre.cybox.cybox_2.ObservableType) |
		//			(org.mitre.cybox.cybox_2.ObjectType) |
		//			(org.mitre.cybox.objects.TaskActionTypeType) |
		//			(org.mitre.cybox.cybox_2.EventType)/: [
		//				'regex':/(?m)(\/\*\*.*)(public void setId.*})/, 'codeTemplate': """\
		//    /**
		//	 * Sets the value of the id property.
		//	 *
		//	 * Helloworld!
		//	 *
		//	 * @param value
		//	 *     allowed object is
		//	 *     {@link QName }
		//	 *
		//	 */
		//    public void setId(QName value) {
		//        this.id = value;
		//        System.out.println("Helloworld!");
		//    }
		//"""
		//			]]

		def dom = []

		new File('src/generated/java').eachFileRecurse(FileType.FILES) { file ->
			if (file.name.endsWith('Type.java') && !file.name.endsWith('EnumType.java')) {

				def obj = new LinkedHashMap();
				obj.uri = file.toURI()
				obj.name = file.getName().split(/\./)[0]
				obj.package = file.getParent().split(Pattern.quote(System.getProperty("file.separator")))[3..-1].join('.')

				dom << obj
			}
		}

		dom.each() { obj ->
			def templateBindings = ["pkg":obj.package, "name":obj.name]

			addMethods.each { regex, methodDeclarations ->

				if ( obj.package + '.' + obj.name ==~ regex) {

					def source = new File(obj.uri).readLines().iterator()
							.join(lineSeperator)

					source = addImportsToSrc(source,
							methodDeclarations['imports'])

					source = addMethodsToSrc(source,
							methodDeclarations['methodTemplates'], templateBindings)

					//			replaceCode.each { regex, replace ->
					//				if ( obj.package + '.' + obj.name ==~ regex) {
					//					if (lines == null) {
					//						lines = new File(obj.uri).readLines().iterator().join("\n")
					//					}
					//
					//					def replacementCode = ""
					//					replace['codeTemplate'].eachLine { line ->
					//						replacementCode += line.replaceAll(/(\$\{pkg\})/, obj.package).replaceAll(/(\$\{name\})/, obj.name) + "\n"
					//					}
					//
					//					lines.replaceAll(replace['regex'], replacementCode)
					//				}
					//			}

					new File( obj.uri ).with { outFile ->
						outFile.setWritable(true)
						outFile.withWriter{ out -> out.println format(source) }
						outFile.setWritable(false)
					}
				}
			}
		}
	}
}

// Dynamically creates the src/main/resources/namespace-prefix.xjb
// file from the schemas otherwise XJC will dynamically assign ns namespaces
class PrefixNamespaceBindingsTask extends DefaultTask {

	// Returns a hashmap Binding objects
	def get() {

		// ignore these namespaces cuz they are orphans
		def notPartOfThisCompilation = [
			"schemas/cybox/external/cpe_2.3/cpe-naming_2.3.xsd",
			"schemas/cybox/external/cpe_2.3/cpe-language_2.3.xsd",
			"schemas/cybox/external/oasis_ciq_3.0/xlink-2003-12-31.xsd"
		]

		// fix paths for present platform
		if (File.separator.equals("\\")) {
			// couldn't get collect to work on windows
			def temp = []
			notPartOfThisCompilation.each {
				temp.add(it.replaceAll("/", "\\\\"))

			}
			notPartOfThisCompilation = temp
		}

		def schemaBindings = [:]

		// Gather up the schemas
		def schemas = []
		new File("src/main/resources/schemas").eachFileRecurse(FileType.FILES) { file ->
			if (file.name.endsWith('.xsd')) {
				schemas << file
			}
		}

		// Gather Binding objects parsed from the schemas.
		schemas.each {schema ->

			def schemaLocation = new File("schemas",
					schema.getAbsolutePath().split("schemas")[1]).toString()

			if (!notPartOfThisCompilation.contains(schemaLocation)) {

				def document = DocumentBuilderFactory.newInstance()
						.newDocumentBuilder().parse(new FileInputStream(schema))

				document.getDocumentElement().normalize()

				def attributes = document.getDocumentElement().getAttributes()

				def binding, attribute, targetNamespace
				for (int i = 0 ; i < attributes.getLength() ; i++) {
					attribute = attributes.item(i)
					targetNamespace = document.getDocumentElement().getAttribute("targetNamespace")

					if (attribute.getNodeName().startsWith("xmlns:") && attribute.getNodeValue().equals(targetNamespace)) {

						binding = new LinkedHashMap()
						binding.prefix = attributes.item(i).getNodeName().split(":")[1]
						binding.namespace = attributes.item(i).getNodeValue()
						binding.schemaLocation = schemaLocation

						schemaBindings[schemaLocation] = binding
					}
				}
			}
		}

		//Add these external schemas
		schemaBindings.put("schemas/external/oasis_ciq_3.0/xAL-types.xsd",
				new Binding(prefix: "xal", namespace: "urn:oasis:names:tc:ciq:xal:3",
				schemaLocation: "schemas/external/oasis_ciq_3.0/xAL-types.xsd"));
		schemaBindings.put("schemas/external/oasis_ciq_3.0/xPIL.xsd",
				new Binding(prefix: "xpil", namespace: "urn:oasis:names:tc:ciq:xpil:3",
				schemaLocation: "schemas/external/oasis_ciq_3.0/xPIL.xsd"));
		schemaBindings.put("schemas/external/oasis_ciq_3.0/xNL-types.xsd",
				new Binding(prefix: "xnl", namespace: "urn:oasis:names:tc:ciq:xnl:3",
				schemaLocation: "schemas/external/oasis_ciq_3.0/xNL-types.xsd"));
		// The crawl would map the 'tns' prefix to both of these... fix that.
		schemaBindings.put("schemas/external/open_ioc_2010/ioc-TR.xsd",
				new Binding(prefix: "ioc-tr", namespace: "urn:oasis:names:tc:ciq:xnl:3",
				schemaLocation: "schemas/external/open_ioc_2010/ioc-TR.xsd"));
		schemaBindings.put("schemas/external/open_ioc_2010/ioc.xsd",
				new Binding(prefix: "ioc", namespace: "urn:oasis:names:tc:ciq:xnl:3",
				schemaLocation: "schemas/external/open_ioc_2010/ioc.xsd"));

		//		schemaBindings.each{ k, v ->
		//			println "${k} : ${v.namespace}, ${v.prefix}"
		//		}

		schemaBindings
	}

	// Dynamically creates the src/main/resources/namespace-prefix.xjb file used by XJC jaxb2-namespace-prefix plugin
	@TaskAction
	def create() {
		def schemaBindings = get()

		def dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
		def date = new Date();

		def xmlBuilder = new StreamingMarkupBuilder()
		def writer = xmlBuilder.bind {
			mkp.comment "WARNING!!!!! Dynamically created on ${dateFormat.format(date)} by the build.gradle's createPrefixNamespaceBindings task. All changes made to this file will be lost."
			mkp.declareNamespace(jaxb:"http://java.sun.com/xml/ns/jaxb")
			mkp.declareNamespace(xsi:"http://www.w3.org/2001/XMLSchema-instance")
			mkp.declareNamespace(xs:"http://www.w3.org/2001/XMLSchema")
			mkp.declareNamespace(namespace:"http://jaxb2-commons.dev.java.net/namespace-prefix")
			'jaxb:bindings'(version: "2.1", "xsi:schemaLocation":"http://java.sun.com/xml/ns/jaxb http://java.sun.com/xml/ns/jaxb/bindingschema_2_0.xsd http://jaxb2-commons.dev.java.net/namespace-prefix http://java.net/projects/jaxb2-commons/sources/svn/content/namespace-prefix/trunk/src/main/resources/prefix-namespace-schema.xsd") {
				schemaBindings.each { schemaLocation, binding ->
					'jaxb:bindings'(schemaLocation: schemaLocation) {
						'namespace:prefix'(name: binding.prefix)
					}
				}
			}
		}
		new File("src/main/resources/namespace-prefix.xjb")
				.setText(XmlUtil.serialize(writer.toString()))
	}
}

jar {
	manifest {
		attributes 'Specification-Title': 'Structured Threat Information eXpression (STIX)',
		'Specification-Version': '1.1.1',
		'Implementation-Title': 'Java-STIX',
		'Implementation-Version': version,
		'Implementation-Vendor': 'The MITRE Corporation'
	}
}

sourceSets {
	main {
		java { srcDirs('src/main/java', 'src/generated/java') }
		resources {
			srcDir('src/main/resources')
			exclude '*.xjb' // not needed in the jar
		}
	}
}

repositories {
	jcenter()
	mavenCentral()

	// TODO: Used for prototyping groovy code. strip out later.
	flatDir { dirs 'libs' }
}

configurations { xjc }

dependencies {
	xjc 'com.sun.xml.bind:jaxb-xjc:2.2.5-2'
	xjc 'com.sun.xml.bind:jaxb-impl:2.2.5-2'
	xjc 'javax.xml.bind:jaxb-api:2.2.+'

	// JAXB2 Basics provides a package of plugins which can generate such
	// utility code
	xjc 'org.jvnet.jaxb2_commons:jaxb2-basics:0.6.5'
	xjc 'org.jvnet.jaxb2_commons:jaxb2-basics-ant:0.6.5'

	// Causes JAXB RI 2 XJC to generate additional methods that allows method
	// chaining.
	xjc 'org.jvnet.jaxb2_commons:jaxb2-fluent-api:3.0'

	// Causes JAXB RI 2 XJC to generate a value constructor, where each
	// embedded element is included as a constructor parameter.
	xjc 'org.jvnet.jaxb2_commons:jaxb2-value-constructor:3.0'

	// Causes JAXB RI 2.2 XJC to automatically generate methods for toString(),
	// equals() and hashCode() using jakarta-commons-lang. The code that uses
	// this plugin can still run with any JAXB2 implementation.
	//xjc 'org.jvnet.jaxb2_commons:jaxb2-commons-lang:2.4'

	// This plugin uses the XML schema "element" tag's "default" attribute to
	// set default values for variables in the classes generated by JAXB
	xjc 'org.jvnet.jaxb2_commons:jaxb2-default-value:1.1'

	// This plugin adds 'javax.xml.bind.annotation.XmlNs' annotations to
	// 'package-info.java' file according to specific definitions in
	// bindings.xml file. Those annotations associate namespace prefixes
	// with XML namespace URIs.
	xjc 'org.jvnet.jaxb2_commons:jaxb2-namespace-prefix:1.1'

	compile 'javax.xml.bind:jaxb-api:2.2.+'
	compile 'org.jvnet.jaxb2_commons:jaxb2-basics-runtime:0.6.5'
	compile 'org.apache.httpcomponents:httpclient:4.3.5'
	compile 'org.apache.httpcomponents:httpclient-cache:4.3.5'
	compile 'org.apache.httpcomponents:httpmime:4.3.5'
	compile 'org.apache.httpcomponents:fluent-hc:4.3.5'

	// TODO: This block used for prototyping AST code. Strip out later.
	compile name: 'org.eclipse.core.runtime_3.10.0.v20140318-2214'
	compile name: 'org.eclipse.osgi_3.10.0.v20140606-1445'
	compile name: 'org.eclipse.core.contenttype_3.4.200.v20140207-1251'
	compile name: 'org.eclipse.equinox.common_3.6.200.v20130402-1505'
	compile name: 'org.eclipse.text_3.5.300.v20130515-1451'
	compile name: 'org.eclipse.core.jobs_3.6.0.v20140424-0053'
	compile name: 'org.eclipse.equinox.preferences_3.5.200.v20140224-1527'
	compile name: 'org.eclipse.core.resources_3.9.0.v20140514-1307'
	compile name: 'org.eclipse.jdt.core_3.10.0.v20140604-1726'
	compile name: 'org.eclipse.equinox.registry_3.5.400.v20140428-1507'
}

buildscript {
	repositories {
		jcenter()
		mavenCentral()

		flatDir { dirs 'libs' }
	}

	dependencies {
		classpath name: 'org.eclipse.core.runtime_3.10.0.v20140318-2214'
		classpath name: 'org.eclipse.osgi_3.10.0.v20140606-1445'
		classpath name: 'org.eclipse.core.contenttype_3.4.200.v20140207-1251'
		classpath name: 'org.eclipse.equinox.common_3.6.200.v20130402-1505'
		classpath name: 'org.eclipse.text_3.5.300.v20130515-1451'
		classpath name: 'org.eclipse.core.jobs_3.6.0.v20140424-0053'
		classpath name: 'org.eclipse.equinox.preferences_3.5.200.v20140224-1527'
		classpath name: 'org.eclipse.core.resources_3.9.0.v20140514-1307'
		classpath name: 'org.eclipse.jdt.core_3.10.0.v20140604-1726'
		classpath name: 'org.eclipse.equinox.registry_3.5.400.v20140428-1507'
	}
}

// Dynamically create the prefix-namespace bindings file
// off of the schemas
task createPrefixNamespaceBindings(type: PrefixNamespaceBindingsTask)

// Crawl generated document object model perfoming sytantical analysis for the
// purpose of tranformations (e.g., adding methods)
task generatedSourceTransformation(type: GeneratedSourceTransformationTask)

// Automatically attempt to retrieve the schemas
task retrieveSchemas(type: RetrieveSchemasTask)

// Clean out the generated folder
task cleanGenerate << {
	ant.delete(dir: 'src/generated/java')
}

// Generate the JAXB Document Model
task generateJAXB << {
	ant.taskdef(name: 'xjc', classname: 'org.jvnet.jaxb2_commons.xjc.XJC2Task', classpath: configurations.xjc.asPath)

	ant.mkdir(dir: 'src/generated/java')

	ant.xjc(destdir: 'src/generated/java', extension: true, classpath: configurations.xjc.asPath) {
		arg(line: '-readOnly -verbose -Xequals -XhashCode -Xfluent-api -Xvalue-constructor -Xdefault-value -Xnamespace-prefix -Xinject-code -XtoString')
		binding(dir: 'src/main/resources', includes: '*.xjb')
		schema(dir: 'src/main/resources/schemas', includes: 'cybox/cybox_core.xsd')
		schema(dir: 'src/main/resources/schemas', includes: 'cybox/cybox_common.xsd')
		schema(dir: 'src/main/resources/schemas', includes: 'cybox/cybox_default_vocabularies.xsd')
		schema(dir: 'src/main/resources/schemas', includes: 'cybox/objects/*.xsd')
		schema(dir: 'src/main/resources/schemas', includes: '*.xsd')
		schema(dir: 'src/main/resources/schemas', includes: 'extensions/**/*.xsd')
		schema(dir: 'src/main/resources/schemas', includes: 'external/**/*.xsd')

		//Doing it this way, xjc cannot find its way to all the imported schemas ...
		//schema(dir: 'src/main/resources/schemas', includes: '**/*.xsd')
	}
}

generateJAXB.dependsOn cleanGenerate, retrieveSchemas

generatedSourceTransformation.dependsOn generateJAXB

compileJava.dependsOn createPrefixNamespaceBindings, generatedSourceTransformation
