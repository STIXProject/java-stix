/*
 * Copyright (c) 2015, The MITRE Corporation. All rights reserved.
 * See LICENSE for complete terms.
 *
 * Java-STIX Gradle Buildscript
 *
 * nemonik (Michael Joseph Walsh <github.com@nemonik.com>)
 *
 * Run
 *
 *	gradle
 *
 * from the commnand-line.
 *
 * Jar will be built to 
 *
 * 	build/libs/java-stix-${version}.jar
 */

import groovy.io.FileType
import groovy.text.SimpleTemplateEngine
import groovy.xml.StreamingMarkupBuilder
import groovy.xml.XmlUtil

import java.io.ByteArrayInputStream
import java.io.File
import java.nio.file.FileSystems
import java.io.InputStream
import java.text.SimpleDateFormat
import java.util.ArrayList;
import java.util.Date
import java.util.Hashtable;
import java.util.List
import java.util.Map;
import java.util.regex.Matcher
import java.util.regex.Pattern

import javax.xml.bind.JAXBContext
import javax.xml.bind.JAXBElement
import javax.xml.bind.JAXBException
import javax.xml.bind.Marshaller
import javax.xml.bind.Unmarshaller
import javax.xml.namespace.QName
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.parsers.ParserConfigurationException
import javax.xml.transform.stream.StreamSource

import org.eclipse.jdt.core.JavaCore
import org.eclipse.jdt.core.ToolFactory
import org.eclipse.jdt.core.compiler.IProblem
import org.eclipse.jdt.core.dom.AST
import org.eclipse.jdt.core.dom.ASTNode
import org.eclipse.jdt.core.dom.ASTParser
import org.eclipse.jdt.core.dom.CompilationUnit
import org.eclipse.jdt.core.dom.ImportDeclaration
import org.eclipse.jdt.core.dom.TypeDeclaration
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite
import org.eclipse.jdt.core.dom.rewrite.ListRewrite
import org.eclipse.jdt.core.formatter.CodeFormatter
import org.eclipse.jdt.core.formatter.DefaultCodeFormatterConstants
import org.eclipse.jface.text.Document
import org.eclipse.text.edits.TextEdit

import org.w3c.dom.Document
import org.apache.tools.ant.taskdefs.condition.Os

import org.gradle.plugins.signing.Sign

import org.mitre.stix.HelloWorldTask

apply plugin: "java"

apply plugin: "groovy"

apply plugin: "eclipse"
apply plugin: 'maven'
apply plugin: 'signing'


defaultTasks "jar"

// TODO: use stixShemaVersion and version
version = "1.1.1"
//ext.isReleaseVersion = !version.endsWith("SNAPSHOT")
group = "org.mitre"
archivesBaseName = "stix"

task helloworld(type: HelloWorldTask) {}

// Will attempt to automatically retrieve the schemas
class RetrieveSchemasTask extends DefaultTask {
	
	def patch() {
		println("    Patching src/main/resources/schemas/v1.1.1/cybox/objects/Archive_File_Object.xsd")
		ant.patch(patchfile: "cybox_object_archive_file_object.patch", originalfile: 'src/main/resources/schemas/v1.1.1/cybox/objects/Archive_File_Object.xsd')
	}
	
	def pull() {
	
		def command = null

		if (Os.isFamily(Os.FAMILY_WINDOWS)) {
			command = "cmd /c retrieve_schemas.bat"
		} else {
			command = "sh ./retrieve_schemas.sh"
		}

		def proc = command.execute(null, project.rootDir)
		proc.waitFor()

		println("    ${proc.in.text}")
	}

	@TaskAction
	def retrieve() {
		if ((project.file("src/main/resources/schemas/v1.1.1").list().size() == 0) || (project.file("src/main/resources/schemas/v1.1.1/cybox").list() == null)) {
			pull()
			patch()
			if ((project.file("src/main/resources/schemas/v1.1.1").list().size() == 0) || (project.file("src/main/resources/schemas/v1.1.1/cybox").list() == null)) {
				throw new GradleException("    Build error occurred: You will need retrieve schemas by hand. See README.md file.");
			}
		} else {
			println("    Schemas are present. Retrieval is not needed.")
		}
	}
}

task retrieveSchemas(type: RetrieveSchemasTask, dependsOn: clean) {
	description "Automatically attempt to retrieve the schemas."
}


// Dynamically creates the 
//      src/main/resources/namespace-prefix.xjb

// file from the schemas.
//
// namespace-prefix.xjb prevents XJC from dynamically assigning ns namespaces
// and catalog.xml is used for parsing and validation.
class PrefixNamespaceBindingsTask extends DefaultTask {
	
	// Returns a hashmap Binding objects
	def get() {
	
		// ignore these namespaces cuz they are orphans
		def notPartOfThisCompilation = [
			"schemas/v1.1.1/cybox/external/cpe_2.3/cpe-naming_2.3.xsd",
			"schemas/v1.1.1/cybox/external/cpe_2.3/cpe-language_2.3.xsd",
			"schemas/v1.1.1/cybox/external/oasis_ciq_3.0/xlink-2003-12-31.xsd"
		]

		// fix paths for present platform
		if (File.separator.equals("\\")) {
			// couldn't get collect to work on windows
			def temp = []
			notPartOfThisCompilation.each {
				temp.add(it.replaceAll("/", "\\\\"))

			}
			notPartOfThisCompilation = temp
		}

		def prefixSchemaBindings = [:]

		// Gather up the schemas
		def schemas = []
		project.file("src/main/resources/schemas/v1.1.1").eachFileRecurse(FileType.FILES) { file ->
			if (file.name.endsWith(".xsd")) {
				schemas << file
			}
		}	
		
		schemas.each {schema ->

			def schemaLocation = "schemas/v1.1.1" + schema.getAbsolutePath().split("schemas/v1.1.1")[1]
			
			if (!notPartOfThisCompilation.contains(schemaLocation)) {
	
				def document = DocumentBuilderFactory.newInstance()
						.newDocumentBuilder().parse(new FileInputStream(schema))
	
				document.getDocumentElement().normalize()
	
				def attributes = document.getDocumentElement().getAttributes()
	
				def attribute, targetNamespace, prefix
								
				for (int i = 0 ; i < attributes.getLength() ; i++) {
					attribute = attributes.item(i)
					targetNamespace = document.getDocumentElement().getAttribute("targetNamespace")
	
					if (attribute.getNodeName().startsWith("xmlns:") && attribute.getNodeValue().equals(targetNamespace)) {
	
						prefix = attributes.item(i).getNodeName().split(":")[1]
						
						if (prefixSchemaBindings.containsKey(prefix)) {
							//TODO: change to logging.
							logger.warn("    " + schemaLocation + " claims the same prefix \"" + prefix + "\" as " + prefixSchemaBindings[prefix])
						} else {
							prefixSchemaBindings[prefix] = schemaLocation
						}
					}
				}
			}
		}

		//Add these external schemas
		prefixSchemaBindings["xal"] = "schemas/v1.1.1/external/oasis_ciq_3.0/xAL-types.xsd"	
		prefixSchemaBindings["xpil"] = "schemas/v1.1.1/external/oasis_ciq_3.0/xPIL.xsd"
		prefixSchemaBindings["xnl"] = "schemas/v1.1.1/external/oasis_ciq_3.0/xNL-types.xsd"
		
		// Rename "maecPackage" to "maec"
		prefixSchemaBindings.remove("maecPackage")
		prefixSchemaBindings["maec"] = "schemas/v1.1.1/external/maec_4.1/maec_package_schema.xsd"

		// The crawl would map the 'tns' prefix to both of these... fix that.
		prefixSchemaBindings.remove("tns")
		prefixSchemaBindings["ioc-tr"] = "schemas/v1.1.1/external/open_ioc_2010/ioc-TR.xsd"
		prefixSchemaBindings["ioc"] = "schemas/v1.1.1/external/open_ioc_2010/ioc.xsd"

//		prefixSchemaBindings.each{ k, v ->
//			log.info("---> ${k} : ${v}")
//		}

		prefixSchemaBindings
	}

	// Dynamically creates the src/main/resources/namespace-prefix.xjb file used by XJC jaxb2-namespace-prefix plugin
	@TaskAction
	def create() {
	
		def prefixSchemaBindings = get()

		def dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
		def date = new Date();

		def xmlBuilder = new StreamingMarkupBuilder()
		def writer = xmlBuilder.bind {
			mkp.comment "WARNING!!!!! Dynamically created on ${dateFormat.format(date)} by the build.gradle's createPrefixNamespaceBindings task. All changes made to this file will be lost."
			mkp.declareNamespace(jaxb:"http://java.sun.com/xml/ns/jaxb")
			mkp.declareNamespace(xsi:"http://www.w3.org/2001/XMLSchema-instance")
			mkp.declareNamespace(xs:"http://www.w3.org/2001/XMLSchema")
			mkp.declareNamespace(namespace:"http://jaxb2-commons.dev.java.net/namespace-prefix")
			'jaxb:bindings'(version: "2.1", "xsi:schemaLocation":"http://java.sun.com/xml/ns/jaxb http://java.sun.com/xml/ns/jaxb/bindingschema_2_0.xsd http://jaxb2-commons.dev.java.net/namespace-prefix http://java.net/projects/jaxb2-commons/sources/svn/content/namespace-prefix/trunk/src/main/resources/prefix-namespace-schema.xsd") {
				prefixSchemaBindings.each { prefix, schemaLocation ->
					'jaxb:bindings'(schemaLocation:schemaLocation) {
						'namespace:prefix'(name: prefix)
					}
				}
			}
		}
		
		project.file("src/main/resources/namespace-prefix.xjb")
				.setText(XmlUtil.serialize(writer.toString()))
				
	}
}

task createPrefixNamespaceBindings(type: PrefixNamespaceBindingsTask, dependsOn: retrieveSchemas) {
	description "Dynamically create the prefix-namespace bindings file off of the schemas"
}

task generateJAXB(dependsOn: createPrefixNamespaceBindings) << {

	ant.taskdef(name: "xjc", classname: "org.jvnet.jaxb2_commons.xjc.XJC2Task", classpath: configurations.xjc.asPath)

	ant.mkdir(dir: "src/generated/java")
	
	def schemaDir = "src/main/resources/schemas/v" + version

	ant.xjc(destdir: "src/generated/java", extension: true, classpath: configurations.xjc.asPath) {
		arg(line: "-readOnly -verbose -Xequals -XhashCode -Xfluent-api -Xvalue-constructor -Xdefault-value -Xnamespace-prefix -Xinject-code -XtoString")
		binding(dir: "src/main/resources", includes: "*.xjb")
		schema(dir: schemaDir, includes: "cybox/cybox_core.xsd")
		schema(dir: schemaDir, includes: "cybox/cybox_common.xsd")
		schema(dir: schemaDir, includes: "cybox/cybox_default_vocabularies.xsd")
		schema(dir: schemaDir, includes: "cybox/objects/*.xsd")
		//schema(dir: schemaDir, excludes: "cybox/external/**/*.xsd")
		schema(dir: schemaDir, includes: "*.xsd")
		schema(dir: schemaDir, includes: "extensions/**/*.xsd")
		schema(dir: schemaDir, includes: "external/**/*.xsd")
		//Doing it this way, xjc cannot find its way to all the imported schemas ...
		//schema(dir: schemaDir, includes: "**/*.xsd")
	}
}

generateJAXB.description "Generate the JAXB Document Model"

// Analyze and transform the generated document object model source. Creating
// an XJC plug would take too long and introduce the compilation of an external
// project as a dependency, and adding them via bindings file is too brittle.
// So, gradle to the rescue.
class GeneratedSourceTransformationTask extends DefaultTask {

	def lineSeperator = System.getProperty("line.separator")

	// Format src
	def format(src) {

		def options = DefaultCodeFormatterConstants.getEclipseDefaultSettings()
		options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5)
		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_5)
		options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_5)

		def codeFormatter = ToolFactory.createCodeFormatter(options)

		def edit = codeFormatter.format(
				CodeFormatter.K_COMPILATION_UNIT,
				src,
				0,
				src.length(),
				0,
				lineSeperator
				)

		def document = new org.eclipse.jface.text.Document(src)

		try {
			edit.apply(document)
		} catch (Exception e) {
			e.printStackTrace()
		}

		document.get()
	}

	// Add a imports to source and organizes them
	def addImportsToSrc(source, importsToAdd) {
		def document = new org.eclipse.jface.text.Document(source)

		def parser = ASTParser.newParser(AST.JLS8)

		def options = JavaCore.getOptions()
		options.put(JavaCore.COMPILER_COMPLIANCE, "1.5")
		options.put(JavaCore.COMPILER_SOURCE, "1.5")
		parser.setCompilerOptions(options)

		parser.setSource(document.get().toCharArray())
		parser.setKind(ASTParser.K_COMPILATION_UNIT)

		def cu = (CompilationUnit) parser.createAST(null)
		
		if (!(cu.types().get(0) instanceof org.eclipse.jdt.core.dom.EnumDeclaration)) {
			cu.recordModifications()
	
			def ast = cu.getAST();
	
			def importMembers = []
	
			cu.imports().each { importDecl ->
				importMembers << importDecl.getName().toString()
			}
	
			cu.imports().clear()
	
			importsToAdd.each { member ->
				if (!importMembers.contains(member)) {
					importMembers << member
				}
			}
	
			importMembers.sort()
	
			importMembers.each { member ->
				def importDeclaration = ast.newImportDeclaration();
				importDeclaration.setName(ast.newName(member.split("\\.")))
	
				cu.imports().add(importDeclaration)
			}
	
			TextEdit edits = cu.rewrite(document, null)
			edits.apply(document)
		}

		document.get()
	}

	// Add methods to source
	def addMethodsToSrc(source, methodTemplates, templateBindings) {

		def document = new org.eclipse.jface.text.Document(source)
		def parser = ASTParser.newParser(AST.JLS8)

		def options = JavaCore.getOptions()
		options.put(JavaCore.COMPILER_COMPLIANCE, "1.5")
		options.put(JavaCore.COMPILER_SOURCE, "1.5")

		parser.setCompilerOptions(options)

		parser.setSource(document.get().toCharArray())
		parser.setKind(ASTParser.K_COMPILATION_UNIT)

		def cu = (CompilationUnit) parser.createAST(null)
		
		if (!(cu.types().get(0) instanceof org.eclipse.jdt.core.dom.EnumDeclaration)) {
			cu.recordModifications()
	
			def rewriter = ASTRewrite.create(cu.getAST())
	
			def engine = new SimpleTemplateEngine()

			methodTemplates.each { methodTemplate ->
				def template = engine.createTemplate(methodTemplate).make(templateBindings)
				def methodSource = template.toString()

				def lrw = rewriter.getListRewrite((TypeDeclaration) cu.types().get(0),
						TypeDeclaration.BODY_DECLARATIONS_PROPERTY)

				lrw.insertLast(rewriter.createStringPlaceholder(methodSource,
						ASTNode.METHOD_DECLARATION), null)

			}

			def edits = rewriter.rewriteAST(document, null)
			edits.apply(document)
			
		}

		document.get()
	}

	@TaskAction
	def sourceTransformation() {

		def addMethods = [
			/(.*)/: [
				imports: [
					"java.io.StringReader",
					"java.io.StringWriter",
					"javax.xml.bind.JAXBContext",
					"javax.xml.bind.JAXBElement",
					"javax.xml.bind.JAXBException",
					"javax.xml.bind.Marshaller",
					"javax.xml.bind.Unmarshaller",
					"javax.xml.namespace.QName",
					"javax.xml.parsers.DocumentBuilderFactory",
					"javax.xml.parsers.ParserConfigurationException",
					"javax.xml.transform.stream.StreamSource",
					"org.mitre.stix.Utilities",
					"org.mitre.stix.STIXSchema",
					"org.mitre.stix.ValidationEventHandler"
				],
				methodTemplates: [
					"""\
	/**
	 * Returns XML String for JAXB Document Object Model object.
	 *
	 * @return the XML String for the JAXB object
	 */
	public String toXMLString() {

		org.w3c.dom.Document document;
		Marshaller marshaller;
		
		try {
			document = DocumentBuilderFactory.newInstance()
					.newDocumentBuilder().newDocument();

			JAXBContext jaxbContext = JAXBContext.newInstance(this.getClass()
					.getPackage().getName());
	
			marshaller = jaxbContext.createMarshaller();

			// pretty print
			marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
			marshaller.setProperty(Marshaller.JAXB_ENCODING, "UTF-8");
			
			marshaller.setSchema(STIXSchema.getInstance().getSchema());
			marshaller.setEventHandler(new ValidationEventHandler());

								
			try {
				marshaller.marshal(this, document);
			} catch (JAXBException e) {
				// otherwise handle non-XMLRootElements
				QName qualifiedName = new QName(Utilities.getnamespaceURI(this),
						this.getClass().getSimpleName());
	
				@SuppressWarnings({ "rawtypes", "unchecked" })
				JAXBElement root = new JAXBElement(qualifiedName, this.getClass(),
						this);
	
				marshaller.marshal(root, document);
			}
	
			Utilities.removeUnusedNamespaces(document);
	
			return Utilities.getXMLString(document);		
	
		} catch (ParserConfigurationException e) {
			throw new RuntimeException(e);
		} catch (JAXBException e) {
			throw new RuntimeException(e);
		}	}
""",
					"""\
	/**
	 * Creates JAXB Document Object Model for XML text string
	 * 
	 * @param text
	 *            XML string for the document
	 * @return JAXB object
	 */
	public static \${name} fromXMLString(String text) {

		JAXBContext jaxbContext;

		try {
			jaxbContext = JAXBContext.newInstance(\${name}.class.getPackage()
					.getName());

			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
			
			unmarshaller.setSchema(STIXSchema.getInstance().getSchema());
			unmarshaller.setEventHandler(new ValidationEventHandler());

			StreamSource streamSource = new StreamSource(new StringReader(text));
			return (\${name}) unmarshaller.unmarshal(streamSource);

		} catch (JAXBException e) {
			throw new RuntimeException(e);
		} 
	}
""",
					"""\
    /**
     * Validates the XML representation of this JAXB Document 
     * Object Model object. Returning true indicating a successful
     * validation, false if not.
     * 
     * @return boolean
     */
    public boolean validate() {
        return STIXSchema.getInstance().validate(toXMLString());
    }
"""
				]]]

		//		def replaceCode = [
		//			/(org.mitre.stix.stix_1.STIXType) |
		//			(org.mitre.stix.indicator_2.IndicatorType) |
		//			(org.mitre.stix.incident_1.IncidentType) |
		//			(org.mitre.stix.ttp_1.TTPType) |
		//			(org.mitre.stix.threatactor_1.ThreatActorType) |
		//			(org.mitre.stix.campaign_1.CampaignType) |
		//			(org.mitre.stix.exploittarget_1.ExploitTargetType) |
		//			(org.mitre.stix.courseofaction_1.CourseOfActionType) |
		//			(org.mitre.cybox.cybox_2.ObservableType) |
		//			(org.mitre.cybox.cybox_2.ObjectType) |
		//			(org.mitre.cybox.objects.TaskActionTypeType) |
		//			(org.mitre.cybox.cybox_2.EventType)/: [
		//				'regex':/(?m)(\/\*\*.*)(public void setId.*})/, 'codeTemplate': """\
		//    /**
		//	 * Sets the value of the id property.
		//	 *
		//	 * Helloworld!
		//	 *
		//	 * @param value
		//	 *     allowed object is
		//	 *     {@link QName }
		//	 *
		//	 */
		//    public void setId(QName value) {
		//        this.id = value;
		//        System.out.println("Helloworld!");
		//    }
		//"""
		//			]]

		def dom = []

		project.file("src/generated/java").eachFileRecurse(FileType.FILES) { file ->
			if (!file.name.endsWith("package-info.java") && !file.name.endsWith("EnumType.java") && !file.name.endsWith("TypeEnum.java")) {

				def obj = new LinkedHashMap();
				obj.uri = file.toURI()
				obj.name = file.getName().split(/\./)[0]
				obj.package = file.getParent().split(Pattern.quote(System.getProperty("file.separator")))[3..-1].join('.')

				dom << obj
			}
		}

		dom.each() { obj ->
			def templateBindings = ["pkg":obj.package, "name":obj.name]

			addMethods.each { regex, methodDeclarations ->

				if ( obj.package + "." + obj.name ==~ regex) {

					def source = project.file(obj.uri).readLines().iterator()
							.join(lineSeperator)

					source = addImportsToSrc(source,
							methodDeclarations["imports"])

					source = addMethodsToSrc(source,
							methodDeclarations["methodTemplates"], templateBindings)

					//			replaceCode.each { regex, replace ->
					//				if ( obj.package + "." + obj.name ==~ regex) {
					//					if (lines == null) {
					//						lines = project.file(obj.uri).readLines().iterator().join("\n")
					//					}
					//
					//					def replacementCode = ""
					//					replace['codeTemplate'].eachLine { line ->
					//						replacementCode += line.replaceAll(/(\$\{pkg\})/, obj.package).replaceAll(/(\$\{name\})/, obj.name) + "\n"
					//					}
					//
					//					lines.replaceAll(replace["regex"], replacementCode)
					//				}
					//			}

					project.file( obj.uri ).with { outFile ->
						outFile.setWritable(true)
						outFile.withWriter{ out -> out.println format(source) }
						outFile.setWritable(false)
					}
				}
			}
		}
	}
}

task generatedSourceTransformation(type: GeneratedSourceTransformationTask, dependsOn: generateJAXB) {
	description "Perfom syntactical analysis and tranformations on the model (e.g., adding convenience methods)"
}

compileJava.dependsOn generatedSourceTransformation

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from 'LICENSE'
    from javadoc
    // from javadoc.destinationDir
}

task sourcesJar(type: Jar, dependsOn: javadoc) {
    classifier = 'sources'
    from 'LICENSE'
    from 'README.md'
    from sourceSets.main.allSource
}


clean {
	delete("src/generated/java")
	delete("src/main/resources/namespace-prefix.xjb")
}


sourceSets {
	main {
		java { srcDirs("src/main/java", "src/generated/java") }
		resources {
			srcDir("src/main/resources")
			exclude "*.xjb" // not needed in the jar
		}
	}
}

repositories {
	jcenter()
	mavenCentral()

	// TODO: Used for prototyping groovy code. strip out later.
	flatDir { dirs "libs" }
}

configurations { xjc }

dependencies {

	compile localGroovy()
	compile gradleApi()

	xjc "com.sun.xml.bind:jaxb-xjc:2.2.5-2"
	xjc "com.sun.xml.bind:jaxb-impl:2.2.5-2"
	xjc "javax.xml.bind:jaxb-api:2.2.+"

	// JAXB2 Basics provides a package of plugins which can generate such
	// utility code
	xjc "org.jvnet.jaxb2_commons:jaxb2-basics:0.6.5"
	xjc "org.jvnet.jaxb2_commons:jaxb2-basics-ant:0.6.5"

	// Causes JAXB RI 2 XJC to generate additional methods that allows method
	// chaining.
	xjc "org.jvnet.jaxb2_commons:jaxb2-fluent-api:3.0"

	// Causes JAXB RI 2 XJC to generate a value constructor, where each
	// embedded element is included as a constructor parameter.
	xjc "org.jvnet.jaxb2_commons:jaxb2-value-constructor:3.0"

	// Causes JAXB RI 2.2 XJC to automatically generate methods for toString(),
	// equals() and hashCode() using jakarta-commons-lang. The code that uses
	// this plugin can still run with any JAXB2 implementation.
	//xjc "org.jvnet.jaxb2_commons:jaxb2-commons-lang:2.4"

	// This plugin uses the XML schema "element" tag's "default" attribute to
	// set default values for variables in the classes generated by JAXB
	xjc "org.jvnet.jaxb2_commons:jaxb2-default-value:1.1"

	// This plugin adds 'javax.xml.bind.annotation.XmlNs' annotations to
	// 'package-info.java' file according to specific definitions in
	// bindings.xml file. Those annotations associate namespace prefixes
	// with XML namespace URIs.
	xjc "org.jvnet.jaxb2_commons:jaxb2-namespace-prefix:1.1"

	//compile "javax.xml.bind:jaxb-api:2.2.+"
	compile "org.jvnet.jaxb2_commons:jaxb2-basics-runtime:0.6.5"
	compile "org.apache.httpcomponents:httpclient:4.3.5"
	compile "org.apache.httpcomponents:httpclient-cache:4.3.5"
	compile "org.apache.httpcomponents:httpmime:4.3.5"
	compile "org.apache.httpcomponents:fluent-hc:4.3.5"
	
	compile "org.springframework:spring-core:4.1.4.RELEASE"
	
	compile "commons-io:commons-io:2.4"
	
	compile "commons-lang:commons-lang:2.6"
	
	//compile "org.codehaus.jackson:jackson-mapper-asl:1.9.13"
	
	// TODO: This block used for prototyping AST code. Strip out later.
	//compile name: "org.eclipse.core.runtime_3.10.0.v20140318-2214"
	//compile name: "org.eclipse.osgi_3.10.0.v20140606-1445"
	//compile name: "org.eclipse.core.contenttype_3.4.200.v20140207-1251"
	//compile name: "org.eclipse.equinox.common_3.6.200.v20130402-1505"
	//compile name: "org.eclipse.text_3.5.300.v20130515-1451"
	//compile name: "org.eclipse.core.jobs_3.6.0.v20140424-0053"
	//compile name: "org.eclipse.equinox.preferences_3.5.200.v20140224-1527"
	//compile name: "org.eclipse.core.resources_3.9.0.v20140514-1307"
	//compile name: "org.eclipse.jdt.core_3.10.0.v20140604-1726"
	//compile name: "org.eclipse.equinox.registry_3.5.400.v20140428-1507"
}

jar {
	manifest {
		attributes 'Specification-Title': 'Structured Threat Information eXpression (STIX)',
		'Specification-Version': '1.1.1',
		'Implementation-Title': 'Java-STIX',
		'Implementation-Version': version,
		'Implementation-Vendor': 'The MITRE Corporation'
	}
	
	from 'LICENSE'
}

gradle.taskGraph.whenReady { taskGraph ->
    if (taskGraph.allTasks.any { it instanceof Sign }) {
		// these three should be defined out of the repository, for example, in ~/.gradle/gradle.properties
		// or alternatively as environment variables
		
		// signingKeyId = System.properties['signingKeyId']
		// secretKeyFile = System.properties['secretKeyFile']
		// signingPassword = System.properties['signingPassword']	
		
		allprojects { 
			ext."signing.keyId"=signingKeyId
			ext."signing.password"=signingPassword 
			ext."signing.secretKeyRingFile"=secretKeyFile 
		}
    }
}

signing {
	// required { isReleaseVersion && gradle.taskGraph.hasTask("uploadArchives") }
    sign configurations.archives
}

javadoc {
	include "**/org/mitre/stix/**/*"
	include "**/com/mandiant/**/*"
	include "**/gov/nist/**/*"
	include "**/oasis/nist/**/*"
	include "**/org/icasi/**/*"
	include "**/org/mitre/**/*"
	include "**/org/purl/**/*"
	include "**/org/w3/**/*"

	// options.memberLevel = JavadocMemberLevel.PRIVATE
    options.overview = "src/main/javadoc/overview.html";
    options.showAll()
    options.encoding("UTF-8")
    options.setUse(true)
    options.author(true)
    options.version(true)
    options.windowTitle("java-stix v." + version)
    options.docTitle("java-stix v." + version)
    options.footer("Copyright (c) 2015, The MITRE Corporation. All rights reserved.")
    
    doFirst {
        javadoc.title = "java-stix v." + version
        javadoc.options.docTitle = javadoc.title
    }
}

if (JavaVersion.current().isJava8Compatible()) {
    tasks.withType(Javadoc) {
        // disable strict doclint in Java 8
        options.addStringOption('Xdoclint:none', '-quiet')
    }
}

artifacts {
    archives javadocJar, sourcesJar
}

uploadArchives {

    // these two should be defined out of the repository, for example, in ~/.gradle/gradle.properties
	// or alternatively as environment variables

	// ossrhUsername = System.properties['sonotypeJiraId']
	// ossrhPassword= System.properties['sonotypeJiraPassword']
	
	ext."ossrhUsername"=sonotypeJiraId
	ext."ossrhPassword"=sonotypeJiraPassword

	repositories {
    	mavenDeployer {
      		beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

	      	repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
	        	authentication(userName: ossrhUsername, password: ossrhPassword)
	      	}
	
	      	snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots/") {
	        	authentication(userName: ossrhUsername, password: ossrhPassword)
	      	}
	
			pom.project {
	        	name 'stix'
	        	packaging 'jar'
	        	version "${version}-SNAPSHOT" // default is project.version
	        	// optionally artifactId can be defined here 
	        	description "The JAXB Bindings for STIX v." + version
	        	url "https://github.com/nemonik/java_stix"
	
	        	scm {
	          		connection "https://github.com/nemonik/java_stix.git"
	          		developerConnection "https://github.com/nemonik/java_stix.git"
	          		url "https://github.com/nemonik/java_stix"
	        	}
	
	        	licenses {
	          		license {
	            		name "The BSD 3-Clause License"
	            		url "https://raw.githubusercontent.com/nemonik/java_stix/master/LICENSE"
	          		}
	        	}
	
	        	developers {
	        		developer {
	            		id 'nemonik'
	            		name 'Michael Joseph Walsh'
	            		email 'java-stix-pom[ASCII character number 64]nemonik.com'
	          		}
	        	}
	        }
	    }     
    }
}

buildscript {

	repositories {
		jcenter()
		mavenCentral()

		flatDir { dirs "libs" }
	}

	dependencies {
	
	
		classpath name: "org.eclipse.core.runtime_3.10.0.v20140318-2214"
		classpath name: "org.eclipse.osgi_3.10.0.v20140606-1445"
		classpath name: "org.eclipse.core.contenttype_3.4.200.v20140207-1251"
		classpath name: "org.eclipse.equinox.common_3.6.200.v20130402-1505"
		classpath name: "org.eclipse.text_3.5.300.v20130515-1451"
		classpath name: "org.eclipse.core.jobs_3.6.0.v20140424-0053"
		classpath name: "org.eclipse.equinox.preferences_3.5.200.v20140224-1527"
		classpath name: "org.eclipse.core.resources_3.9.0.v20140514-1307"
		classpath name: "org.eclipse.jdt.core_3.10.0.v20140604-1726"
		classpath name: "org.eclipse.equinox.registry_3.5.400.v20140428-1507"

		//classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:1.1"
	}
}
